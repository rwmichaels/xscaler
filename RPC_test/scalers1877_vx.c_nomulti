#define VERSION "V1.0F1"

#define HALLA 1

/*

Pseudo scaler generated by counting hits in 1877

*/

#include <stdlib.h>
#include <stdio.h>
#include <sysLib.h>
#include <sysSymTbl.h>
#include <taskLib.h>

#define VX_FP_TASK 0x0008  /* What do we really need here??? */


#define L1877SIZE 96

struct sfiStruct {
   volatile unsigned long VMESlaveAddress;
   volatile unsigned long* lca1Vout;      
   volatile unsigned long* outregWrite;  
   volatile unsigned long* outregRead;
   volatile unsigned long* dfctrlReg;
   volatile unsigned long* fbProtReg;
   volatile unsigned long* fbArbReg;
   volatile unsigned long* fbCtrlReg;
   volatile unsigned long* lca1Reset;
   volatile unsigned long* lca2Reset;
   volatile unsigned long* fastbusreadback;
   volatile unsigned long* sequencerRamAddressReg;
   volatile unsigned long* sequencerFlowControlReg;
   volatile unsigned long* resetVme2SeqFifo;
   volatile unsigned long* readClockVme2SeqFifo;
   volatile unsigned long* resetSeq2VmeFifo;
   volatile unsigned long* writeClockSeq2VmeFifo;
   volatile unsigned long* writeVme2SeqFifoBase;
   volatile unsigned long* readSeq2VmeFifoBase;
   volatile unsigned long* readSeqFifoFlags;
   volatile unsigned long* readVme2SeqAddressReg;
   volatile unsigned long* readVme2SeqDataReg;
   volatile unsigned long  sequencerOutputFifoSize;
   volatile unsigned long* sequencerReset;
   volatile unsigned long* sequencerEnable;
   volatile unsigned long* sequencerDisable;
   volatile unsigned long* sequencerRamLoadEnable;
   volatile unsigned long* sequencerRamLoadDisable;
   volatile unsigned long* sequencerStatusReg;
   volatile unsigned long* FastbusStatusReg1;
   volatile unsigned long* FastbusStatusReg2;
   volatile unsigned long* FastbusTimeoutReg;
   volatile unsigned long* FastbusArbitrationLevelReg;
   volatile unsigned long* FastbusProtocolInlineReg;
   volatile unsigned long* sequencerFifoFlagAndEclNimInputReg;
   volatile unsigned long* nextSequencerRamAddressReg;
   volatile unsigned long* lastSequencerProtocolReg;
   volatile unsigned long* VmeIrqLevelAndVectorReg;
   volatile unsigned long* VmeIrqMaskReg;
   volatile unsigned long* resetRegisterGroupLca2;
   volatile unsigned long* sequencerTryAgain;
   volatile unsigned long* readVmeTestReg;
   volatile unsigned long* readLocalFbAdBus;
   volatile unsigned long* readVme2SeqDataFifo;
   volatile unsigned long* writeVmeOutSignalReg;
   volatile unsigned long* clearBothLca1TestReg;
   volatile unsigned long* writeVmeTestReg;
   volatile unsigned long* writeAuxReg;
   volatile unsigned long* generateAuxB40Pulse;
};
/* # 21 "/adaqfs/coda/2.5/common/include/SFI_source.h" 2 */
/* # 1 "/adaqfs/coda/2.5/common/include/sfi_fb_macros.h" 1 */
extern volatile struct sfiStruct sfi;

unsigned int *scalerBuffer;
unsigned int *scalerOverflows;
unsigned int *eorBuffer;
unsigned int *eorOverflows;
int scalerRunInProgress=0;
int scalerBufferSize=0;
int scalerServerExists=0;
int scaler_event_counter=0;
int eor_scaler_event_counter=0;
int scalerReadInProgress=0;
int scalerClearInProgress=0;

struct L1877SCALER {
  unsigned int vxTime0; /* vxWorks time at which scaling started */
  unsigned int vxTime;  /* Current vxWorks time */
  int nevents;    /* Number of events */
  int window_sum; /* Accumlated window in ns */
  int errcnt;
  int *nhitslist;
  int hitlist_size;
};
typedef struct L1877SCALER L1877SCALER;

static int num_1877modules;

static int num_scalers;
static int num_sscalers;
static int num_vscalers;
int scaler_readout_period;
static void *base_scal_addr;
static void *base_sscal_addr;
void *lladdr;

long scaler_readout_killer_flag;

void start_scaler_task();
void set_runstatus(int status);
void start_1877readout_task();

void scalersEor()
     /* Copy the scalers into the end of run buffer */
{
  int i;
  for(i=0;i<scalerBufferSize;i++) {
    eorBuffer[i] = scalerBuffer[i];
    eorOverflows[i] = scalerOverflows[i];
  }
  eor_scaler_event_counter = scaler_event_counter;
  set_runstatus(0);
}
    
void scalersSend(L1877SCALER *l1877scaler)
     /* Called from event list every event.
	Ignore except when a second or 500 events has passed
     */
{
  double timedif;
  int tickdif;
  int nchan;
  int i;
  double ratio;
  unsigned int temp;

  set_runstatus(1);

  tickdif=(l1877scaler->vxTime-l1877scaler->vxTime0);
  if(tickdif < 60 && l1877scaler->nevents < 500) {
    return;
  }
  timedif = tickdif/60.0;
  ratio = timedif/(l1877scaler->window_sum/1000000000.);
  printf("Sum = %d, time=%f, ratio=%f\n",l1877scaler->window_sum,timedif,ratio);
  l1877scaler->window_sum = 0;
  l1877scaler->vxTime0 = l1877scaler->vxTime;

  nchan = num_1877modules*L1877SIZE;
  if(l1877scaler->hitlist_size < nchan) nchan=l1877scaler->hitlist_size;

  for(i=0;i<nchan;i++) {
    temp = scalerBuffer[i];
    scalerBuffer[i] += l1877scaler->nhitslist[i]*ratio;
    if(scalerBuffer[i] < temp) scalerOverflows[i]++;
    l1877scaler->nhitslist[i]=0;
  }
  i = num_1877modules*L1877SIZE;
  temp =  scalerBuffer[i];
  scalerBuffer[i]+=l1877scaler->nevents;
  if(scalerBuffer[i] < temp) scalerOverflows[i]++;
  l1877scaler->nevents=0;
  scaler_event_counter = scalerBuffer[i];
  
  i++;
  temp = scalerBuffer[i];
  scalerBuffer[i]+=tickdif;
  if(scalerBuffer[i] < temp) scalerOverflows[i]++;


}
  

void setup_scalers(int n1877,int between_runs)
{
  int jj,res;
  char *S_ADDR, *SS_ADDR;


  void *scal_addr;
  char *s;
  void (*pscaSrvr)();
  SYM_TYPE symtype;
  STATUS symstat;
  int i;

  daLogMsg("INFO","Setup scalers.  Version %s @%d\n",VERSION,tickGet());


  num_1877modules = n1877;

  scalerBufferSize = L1877SIZE*num_1877modules+2;

  scalerBuffer = (unsigned int *) malloc(scalerBufferSize*sizeof(int));
  scalerOverflows = (unsigned int *) malloc(scalerBufferSize*sizeof(int));
  eorBuffer = (unsigned int *) malloc(scalerBufferSize*sizeof(int));
  eorOverflows = (unsigned int *) malloc(scalerBufferSize*sizeof(int));

  for(i=0;i<scalerBufferSize;i++) {
    scalerBuffer[i] = 0;
    scalerOverflows[i] = 0;
    eorBuffer[i] = 0;
    eorOverflows[i] = 0;
  }
  scaler_event_counter = 0;


  printf("Scaler buffer \"scalerBuffer\" of %d words alocated and initialized at 0x%x\n",scalerBufferSize,scalerBuffer);
  printf("Scaler overflow buffer \"scalerOverflows\" of %d words alocated and initialized at 0x%x\n",scalerBufferSize,scalerOverflows);
  scalerRunInProgress=0;        /* If !=0, then CODA is running */


  /* Check if the scaler server is loaded, and if so, start up both the
     scaler server and the between run's readout */
  symstat = symFindByName(sysSymTbl,"scaSrvr",(char **)&pscaSrvr,&symtype);
  if(symstat == 0) {
    
    /* Start the scaler server */
    daLogMsg("INFO","Starting scaler server");

    taskSpawn("scSrvr",140,VX_FP_TASK,20000,(FUNCPTR) *pscaSrvr,0,0,0,0,0,0,0,0,0,0);

  }

  if(between_runs) {
    start_1877readout_task();
  }

}

/* Return the number of channels of scalers modules */
int get_num_scalers()
{
  printf("get_num_scalers: %d\n",scalerBufferSize);
  return(scalerBufferSize);
}

void set_runstatus(int status)
{
  scalerRunInProgress = status;
}

int get_runstatus()
{
  return(scalerRunInProgress);
}


/* Copy scalers into array created by scalers server.  Assume that the
   scaler server made first and count sensible values */
struct VALUE {
	int val;
	int ovf;
};
typedef struct VALUE VALUE;

int scalers_copy(VALUE *values, int first, int count)
{
  int i;

  for(i=0;i<count;i++) {
    values[i].val = scalerBuffer[first+i];
    values[i].ovf = scalerOverflows[first+i];
    /*    printf("%d: %d %d\n", first+i, values[i].val, values[i].ovf);*/
  }
  return(scaler_event_counter);
}

int eor_scalers_copy(VALUE *values, int first, int count)
{
  int i;

  for(i=0;i<count;i++) {
    values[i].val = eorBuffer[first+i];
    values[i].ovf = eorOverflows[first+i];
    /*    printf("%d: %d %d\n", first+i, values[i].val, values[i].ovf);*/
  }
  return(eor_scaler_event_counter);
}

void kill_l1877scaler_task()
{
  scaler_readout_killer_flag=1;
}

const CHIP_MASK = 0xff;
/* Use F1TDC library global variables */
const MAX_1877_DATA = 800;
const SFI_ADDR = 0xe0000;

void L1877ReadoutTask() {
  /* Software trigger the F1 TDC's and accumulate hit counts from each
     channel.  Watch for a flag to be set by the readout list telling
     this to give up.
  */
  unsigned long L1877_SCAN_MASK;
  int i,ii;
  unsigned int l1877data[MAX_1877_DATA];
  unsigned int datascan;
  static struct L1877SCALER l1877scaler = {0,0,0,0,0,0,0};
  int slotmap[32];
  unsigned int dataword;
  int slot, lastslot, nwrds, chan, header, itdc;
  int scalchan;
  int L1877_Window=4488;
  int L1877_MinSlot=14;		/* Slots 14, 15, 16 */
  int res;
  unsigned int laddr;
  unsigned int sfi_cpu_mem_offset=0x8000000;

  L1877_Window = (L1877_Window>>3)*8;

  scaler_readout_killer_flag=0;

  for(i=0;i<32;i++) {
    slotmap[i] = -1;
  }
  L1877_SCAN_MASK=0;
  for (i=0; i<num_1877modules; i++) {
    slot = L1877_MinSlot+i;
    L1877_SCAN_MASK |= (1<<slot);
    slotmap[slot]=i;
  }

  l1877scaler.hitlist_size = num_1877modules*96;
  l1877scaler.nhitslist = (int *) malloc(l1877scaler.hitlist_size*sizeof(int));
  for(i=0;i<l1877scaler.hitlist_size;i++) {
    l1877scaler.nhitslist[i] = 0;
  }

  /* Now enable the 1877's */
  res = (unsigned long) sysBusToLocalAdrs(0x39,SFI_ADDR,&laddr);
  if (res != 0) {
     printf("Error Initializing SFI res=%d \n",res);
  } else {
     printf("Calling InitSFI() routine with laddr=0x%x.\n",laddr);
     InitSFI(laddr);
  }
  for(i=0;i<num_1877modules;i++) {
    slot = L1877_MinSlot+i;
    fpwc(slot,0,0x40000000);/* Reset */
    sfi_error_decode(0);
    if(i==0) {
      fpwc(slot,0,0x1100);
    } else if((i+1)==num_1877modules) {
      fpwc(slot,0,0x0900);
    } else {
      fpwc(slot,0,0x1900);
    }
    sfi_error_decode(0);
    fpwc(slot,1,0x40000003);
    sfi_error_decode(0);
    fpwc(slot,18,((L1877_Window>>3)<<4)); /* Allow 16 hits */
    sfi_error_decode(0);
  }    

  /* Create structure to hold accumlated data */


  l1877scaler.vxTime0=tickGet();
  l1877scaler.nevents = 0;
  l1877scaler.window_sum = 0;
  l1877scaler.errcnt = 0;

  while(!scaler_readout_killer_flag) {
    for(i=0;i<num_1877modules;i++) {
      slot = L1877_MinSlot+i;
      fpwc(slot,0,0x800000);	/* Internal com */
    }
    sfi.sequencerEnable = 0;
    printf("Internal COMs sent\n");
    taskDelay(20);		/* Wait for  conversion */
    res=fb_frcm_1(9,0,&datascan,1,0,1,0,0,0);
    printf("Datascan=%8.8x\n",datascan);
    sfi_error_decode(0);
    if((datascan&L1877_SCAN_MASK) == L1877_SCAN_MASK) {
      chan = -1;
      lastslot = 0;
      for(i=0;i<num_1877modules;i++) {
	slot = L1877_MinSlot+i;
	fb_fwc_1(slot,0,0x400,1,1,0,1,0,0,0);
	sfi_error_decode(0);
	printf("Slot %d Next event loaded\n",slot);

	res=fb_frdb_1(slot,0,l1877data+sfi_cpu_mem_offset,4*MAX_1877_DATA,&nwrds,1,0,1,0,0x0a,0,0,1);
	sfi_error_decode(0);
	nwrds /= 4;
	printf("Read %d words, res=%d\n",nwrds,res);
	if(nwrds>=MAX_1877_DATA || nwrds <= 0) {
	  printf("Bad # words %d\n",nwrds);
	} else {
	/* Good data.  Count the hits */
	  for(ii=0;ii<nwrds;ii++) {
	    dataword = l1877data[ii];
	    printf("%d: %8.8x\n",ii,dataword);
	    slot = dataword >> 27;
	    if(lastslot != slot) {
	      header = 1; 	/* Skip first word because it is a header */
	      lastslot = slot;
	    }
	    if(!header) {
	      header = 0;
	      itdc = slotmap[slot];
	      if(itdc>=0&&itdc<num_1877modules) {
		chan = (dataword>>17)&0x3f;
		scalchan = itdc*96+chan;
		l1877scaler.nhitslist[itdc*96+chan]++;
	      }
	    }
	  }
	}
      }
      l1877scaler.vxTime=tickGet();
      l1877scaler.nevents++;
      l1877scaler.window_sum += L1877_Window;
      scalersSend(&l1877scaler);
    } else {
      printf("Bad scanmask=0x%8.8x\n",datascan);
      for(i=0;i<num_1877modules;i++) {
	slot = L1877_MinSlot+i;
	if(datascan & (1<<slot)) {
	  fpwc(slot,0,0x400);	/* Flush event */
	}
      }
    }
  }
  free(l1877scaler.nhitslist);

}

void start_1877readout_task()
{

  daLogMsg("INFO","Starting in-between run reading of 1877 TDC's");
  taskSpawn("l1877scaler",115,VX_FP_TASK,20000,(FUNCPTR) *L1877ReadoutTask,0,0,0,0,0,0,0,0,0,0);
}

