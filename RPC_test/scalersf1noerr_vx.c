#define VERSION "V1.0F1"

#define HALLA 1

/*

Pseudo scaler generated by counting hits in F1

*/

#include <stdlib.h>
#include <stdio.h>
#include <sysLib.h>
#include <sysSymTbl.h>
#include <taskLib.h>

#define VX_FP_TASK 0x0008  /* What do we really need here??? */


#define F1SIZE 64


unsigned int *scalerBuffer;
unsigned int *scalerOverflows;
unsigned int *eorBuffer;
unsigned int *eorOverflows;
int scalerRunInProgress=0;
int scalerBufferSize=0;
int scalerServerExists=0;
int scaler_event_counter=0;
int eor_scaler_event_counter=0;
int scalerReadInProgress=0;
int scalerClearInProgress=0;

struct F1SCALER {
  unsigned int vxTime0; /* vxWorks time at which scaling started */
  unsigned int vxTime;  /* Current vxWorks time */
  int nevents;    /* Number of events */
  int window_sum; /* Accumlated window in ns */
  int errcnt;
  int *nhitslist;
  int hitlist_size;
};
typedef struct F1SCALER F1SCALER;

static int num_f1modules;

static int num_scalers;
static int num_sscalers;
static int num_vscalers;
int scaler_readout_period;
static void *base_scal_addr;
static void *base_sscal_addr;
void *lladdr;

long scaler_readout_killer_flag;

void start_scaler_task();
void set_runstatus(int status);
void start_f1readout_task();

void scalersEor()
     /* Copy the scalers into the end of run buffer */
{
  int i;
  for(i=0;i<scalerBufferSize;i++) {
    eorBuffer[i] = scalerBuffer[i];
    eorOverflows[i] = scalerOverflows[i];
  }
  eor_scaler_event_counter = scaler_event_counter;
  set_runstatus(0);
}
    
void scalersSend(F1SCALER *f1scaler)
     /* Called from event list every event.
	Ignore except when a second or 500 events has passed
     */
{
  double timedif;
  int tickdif;
  int nchan;
  int i;
  double ratio;
  unsigned int temp;

  set_runstatus(1);

  tickdif=(f1scaler->vxTime-f1scaler->vxTime0);
  if(tickdif < 60 && f1scaler->nevents < 500) {
    return;
  }
  timedif = tickdif/60.0;
  ratio = timedif/(f1scaler->window_sum/1000000000.);
/*  printf("Sum = %d, time=%f, ratio=%f\n",f1scaler->window_sum,timedif,ratio);*/
  f1scaler->window_sum = 0;
  f1scaler->vxTime0 = f1scaler->vxTime;

  nchan = num_f1modules*F1SIZE;
  if(f1scaler->hitlist_size < nchan) nchan=f1scaler->hitlist_size;

  for(i=0;i<nchan;i++) {
    temp = scalerBuffer[i];
    scalerBuffer[i] += f1scaler->nhitslist[i]*ratio;
    if(scalerBuffer[i] < temp) scalerOverflows[i]++;
    f1scaler->nhitslist[i]=0;
  }
  i = num_f1modules*F1SIZE;
  temp =  scalerBuffer[i];
  scalerBuffer[i]+=f1scaler->nevents;
  if(scalerBuffer[i] < temp) scalerOverflows[i]++;
  f1scaler->nevents=0;
  scaler_event_counter = scalerBuffer[i];
  
  i++;
  temp = scalerBuffer[i];
  scalerBuffer[i]+=tickdif;
  if(scalerBuffer[i] < temp) scalerOverflows[i]++;


}
  

void setup_scalers(int nf1,int between_runs)
{
  int jj,res;
  char *S_ADDR, *SS_ADDR;


  void *scal_addr;
  char *s;
  void (*pscaSrvr)();
  SYM_TYPE symtype;
  STATUS symstat;
  int i;

  daLogMsg("INFO","Setup scalers.  Version %s @%d\n",VERSION,tickGet());


  num_f1modules = nf1;

  scalerBufferSize = F1SIZE*num_f1modules+2;

  scalerBuffer = (unsigned int *) malloc(scalerBufferSize*sizeof(int));
  scalerOverflows = (unsigned int *) malloc(scalerBufferSize*sizeof(int));
  eorBuffer = (unsigned int *) malloc(scalerBufferSize*sizeof(int));
  eorOverflows = (unsigned int *) malloc(scalerBufferSize*sizeof(int));

  for(i=0;i<scalerBufferSize;i++) {
    scalerBuffer[i] = 0;
    scalerOverflows[i] = 0;
    eorBuffer[i] = 0;
    eorOverflows[i] = 0;
  }
  scaler_event_counter = 0;


  printf("Scaler buffer \"scalerBuffer\" of %d words alocated and initialized at 0x%x\n",scalerBufferSize,scalerBuffer);
  printf("Scaler overflow buffer \"scalerOverflows\" of %d words alocated and initialized at 0x%x\n",scalerBufferSize,scalerOverflows);
  scalerRunInProgress=0;        /* If !=0, then CODA is running */


  /* Check if the scaler server is loaded, and if so, start up both the
     scaler server and the between run's readout */
  symstat = symFindByName(sysSymTbl,"scaSrvr",(char **)&pscaSrvr,&symtype);
  if(symstat == 0) {
    
    /* Start the scaler server */
    daLogMsg("INFO","Starting scaler server");

    taskSpawn("scSrvr",140,VX_FP_TASK,20000,(FUNCPTR) *pscaSrvr,0,0,0,0,0,0,0,0,0,0);

  }

  if(between_runs) {
    start_f1readout_task();
  }

}

/* Return the number of channels of scalers modules */
int get_num_scalers()
{
  return(scalerBufferSize);
}

void set_runstatus(int status)
{
  scalerRunInProgress = status;
}

int get_runstatus()
{
  return(scalerRunInProgress);
}


/* Copy scalers into array created by scalers server.  Assume that the
   scaler server made first and count sensible values */
struct VALUE {
	int val;
	int ovf;
};
typedef struct VALUE VALUE;

int scalers_copy(VALUE *values, int first, int count)
{
  int i;

  for(i=0;i<count;i++) {
    values[i].val = scalerBuffer[first+i];
    values[i].ovf = scalerOverflows[first+i];
    /*    printf("%d: %d %d\n", first+i, values[i].val, values[i].ovf);*/
  }
  return(scaler_event_counter);
}

int eor_scalers_copy(VALUE *values, int first, int count)
{
  int i;

  for(i=0;i<count;i++) {
    values[i].val = eorBuffer[first+i];
    values[i].ovf = eorOverflows[first+i];
    /*    printf("%d: %d %d\n", first+i, values[i].val, values[i].ovf);*/
  }
  return(eor_scaler_event_counter);
}

void kill_f1scaler_task()
{
  scaler_readout_killer_flag=1;
}

const CHIP_MASK = 0xff;
/* Use F1TDC library global variables */
extern int f1MinSlot;
extern int nf1tdc;
extern int f1ID[20];
const MAX_F1_DATA = 16*64*2;

void f1ReadoutTask() {
  /* Software trigger the F1 TDC's and accumulate hit counts from each
     channel.  Watch for a flag to be set by the readout list telling
     this to give up.
  */
  unsigned long F1_SCAN_MASK;
  int i,ii;
  unsigned int f1data[MAX_F1_DATA];
  unsigned int stat;
  static struct F1SCALER f1scaler = {0,0,0,0,0,0,0};
  int slotmap[32];
  unsigned int dataword;
  int slot, if1, nwrds, chan, notheadertrailer;
  int f1_Window=1000;

  scaler_readout_killer_flag=0;

  F1_SCAN_MASK=0;
  for (i=0; i<nf1tdc; i++) {
    F1_SCAN_MASK |= (1<<f1ID[i]);
  }
  for(i=0;i<32;i++) {
    slotmap[i] = -1;
  }
  for(i=0;i<nf1tdc;i++) {
    if(f1ID[i]>=0 && f1ID[i]<32) {
	slotmap[f1ID[i]] = i;
    }
  }
  f1scaler.hitlist_size = nf1tdc*64;
  f1scaler.nhitslist = (int *) malloc(f1scaler.hitlist_size*sizeof(int));
  for(i=0;i<f1scaler.hitlist_size;i++) {
    f1scaler.nhitslist[i] = 0;
  }

  f1Init(0xc00000,0x1000,nf1tdc,0x04);
  f1GEnableData(CHIP_MASK);
  f1GSetBlockLevel(1);
  f1EnableMultiBlock();
  /* Setup 0.5 microsec window and 0.6 microsecond latency */
  /* Setup 1.0 microsec window and 1.05 microsecond latency */
  f1GSetWindow(f1_Window,1050,CHIP_MASK);
  f1GClear();
  /* Set F1tdc to accept software trigger */
  for(i=0;i<nf1tdc;i++) {
    f1SetInputPort(f1ID[i],0);
    f1EnableSoftTrig(f1ID[i]);
  }
  f1GStatus(0);

  /* Create structure to hold accumlated data */


  f1scaler.vxTime0=tickGet();
  f1scaler.nevents = 0;
  f1scaler.window_sum = 0;
  f1scaler.errcnt = 0;

  while(!scaler_readout_killer_flag) {
    for(i=0;i<nf1tdc;i++) {
      f1Trig(f1ID[i]);
    }
    taskDelay(1);
    stat = f1DataScan(0);
    /*    if(stat == F1_SCAN_MASK) {*/
    if(stat !=0) {
      nwrds = f1ReadEvent(f1MinSlot,f1data,MAX_F1_DATA,2);
      if(nwrds>=MAX_F1_DATA || nwrds <= 0) {
	printf("Bad # words %d\n",nwrds);
	f1GClear();
	/*	for(i=0;i<nf1tdc;i++) {
	  f1EnableSoftTrig(f1ID[i]);
	  }*/
      } else {
	/* Good data.  Count the hits */
	chan = -1;
	for(ii=0;ii<nwrds;ii++) {
	  dataword = f1data[ii];
	  slot = dataword >> 27;
	  notheadertrailer = dataword&0x800000;
	  if1 = slotmap[slot];
	  if(notheadertrailer && if1>=0 && if1<nf1tdc) {
	    chan = (dataword>>16)&0x3f;
	    f1scaler.nhitslist[if1*64+chan]++;
	  }
	  /*	  printf("%d %d 0x%8.8x\n",if1,chan,dataword);*/
	}
	f1scaler.vxTime=tickGet();
	f1scaler.nevents++;
	f1scaler.window_sum += f1_Window;
	scalersSend(&f1scaler);
      }	
    } else {
      printf("Bad scanmask=0x%8.8x\n",stat);
      f1GClear();
      taskDelay(1);
      /*      for(i=0;i<nf1tdc;i++) {
	f1Trig(f1ID[i]);
	taskDelay(1);
	}*/
    }
  }
  for(i=0;i<nf1tdc;i++) {
    f1SetInputPort(f1ID[i],1);
    f1DisableSoftTrig(f1ID[i]);
  }
  free(f1scaler.nhitslist);

}

void start_f1readout_task()
{

  daLogMsg("INFO","Starting in-between run reading of F1 TDC's");
  taskSpawn("f1scaler",115,VX_FP_TASK,20000,(FUNCPTR) *f1ReadoutTask,0,0,0,0,0,0,0,0,0,0);
}

